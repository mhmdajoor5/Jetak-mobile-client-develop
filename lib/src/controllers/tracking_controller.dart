import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:intl/intl.dart' show DateFormat;
import 'package:mvc_pattern/mvc_pattern.dart';
import 'package:web_socket_channel/web_socket_channel.dart';
import 'dart:convert';

import '../../generated/l10n.dart';
import '../helpers/helper.dart';
import '../models/order.dart';
import '../models/order/tracking_order_model.dart';
import '../models/order_status.dart';
import '../repository/order/order_track_repo.dart';
import '../repository/order_repository.dart';

class TrackingController extends ControllerMVC {
  Order order = Order();
  List<OrderStatus> orderStatus = <OrderStatus>[];
  late GlobalKey<ScaffoldState> scaffoldKey;

  TrackingController() {
    this.scaffoldKey = new GlobalKey<ScaffoldState>();
  }

  /// TODO make it dynamic
  LatLng restaurantLocation = LatLng(0.0, 0.0);
  LatLng clientLocation = LatLng(0.0, 0.0);
  LatLng driverLocation = LatLng(0.0, 0.0); // ÿ•ÿ∂ÿßŸÅÿ© ŸÖŸàŸÇÿπ ÿßŸÑÿ≥ÿßÿ¶ŸÇ

  // WebSocket ŸÑŸÑÿ™ÿ±ÿßŸÉŸÜÿ¨ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±
  WebSocketChannel? _driverTrackingChannel;
  bool _isDriverTrackingConnected = false;

  // ÿØÿßŸÑÿ© ŸÑŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÄ WebSocket ŸÑŸÑÿ™ÿ±ÿßŸÉŸÜÿ¨ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±
  void connectToDriverTracking(String orderId) {
    try {
      print("üöÄ ÿ®ÿØÿ° ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÄ WebSocket ŸÑŸÑÿ™ÿ±ÿßŸÉŸÜÿ¨ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±");
      print("üì° Channel: order-tracking.$orderId");
      
      // ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖŸàÿ¨ŸàÿØ
      _driverTrackingChannel?.sink.close();
      
      // ÿ•ŸÜÿ¥ÿßÿ° ÿßÿ™ÿµÿßŸÑ WebSocket ÿ¨ÿØŸäÿØ
      _driverTrackingChannel = WebSocketChannel.connect(
        Uri.parse('ws://carrytechnologies.co:6001'),
      );
      
      // ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸàÿßÿ±ÿØÿ©
      _driverTrackingChannel!.stream.listen(
        (data) {
          print("üì® ÿ±ÿ≥ÿßŸÑÿ© Ÿàÿßÿ±ÿØÿ© ŸÖŸÜ WebSocket: $data");
          _handleDriverTrackingMessage(data, orderId);
        },
        onError: (error) {
          print("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä WebSocket: $error");
          _isDriverTrackingConnected = false;
          setState(() {});
          
          // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÜŸÇÿ∑ÿßÿπ ÿßŸÑÿßÿ™ÿµÿßŸÑ
          if (scaffoldKey.currentContext != null) {
            ScaffoldMessenger.of(scaffoldKey.currentContext!).showSnackBar(
              SnackBar(
                content: Text('Live tracking connection lost. Tap to reconnect.'),
                backgroundColor: Colors.orange,
                duration: Duration(seconds: 3),
              ),
            );
          }
        },
        onDone: () {
          print("‚úÖ WebSocket connection closed");
          _isDriverTrackingConnected = false;
          setState(() {});
          
          // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿßÿ™ÿµÿßŸÑ
          if (scaffoldKey.currentContext != null) {
            ScaffoldMessenger.of(scaffoldKey.currentContext!).showSnackBar(
              SnackBar(
                content: Text('Live tracking connection closed.'),
                backgroundColor: Colors.grey,
                duration: Duration(seconds: 2),
              ),
            );
          }
        },
      );
      
      // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä channel
      _subscribeToDriverTracking(orderId);
      
      _isDriverTrackingConnected = true;
      setState(() {});
      
      print("‚úÖ ÿ™ŸÖ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÄ WebSocket ÿ®ŸÜÿ¨ÿßÿ≠");
      
      // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿ¨ÿßÿ≠ ÿßŸÑÿßÿ™ÿµÿßŸÑ
      if (scaffoldKey.currentContext != null) {
        ScaffoldMessenger.of(scaffoldKey.currentContext!).showSnackBar(
          SnackBar(
            content: Text('Live tracking connected successfully!'),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
      }
      
    } catch (e) {
      print("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÄ WebSocket: $e");
      _isDriverTrackingConnected = false;
      setState(() {});
    }
  }

  // ÿØÿßŸÑÿ© ŸÑŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä channel ÿßŸÑÿ™ÿ±ÿßŸÉŸÜÿ¨
  void _subscribeToDriverTracking(String orderId) {
    try {
      final subscribeMessage = {
        'event': 'subscribe',
        'channel': 'order-tracking.$orderId',
        'data': {
          'order_id': orderId,
        }
      };
      
      _driverTrackingChannel?.sink.add(json.encode(subscribeMessage));
      print("üì° ÿ™ŸÖ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä channel: order-tracking.$orderId");
      
    } catch (e) {
      print("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ: $e");
    }
  }

  // ÿØÿßŸÑÿ© ŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸàÿßÿ±ÿØÿ© ŸÖŸÜ WebSocket
  void _handleDriverTrackingMessage(dynamic data, String orderId) {
    try {
      final message = json.decode(data.toString());
      print("üì® ŸÖÿπÿßŸÑÿ¨ÿ© ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ÿ±ÿßŸÉŸÜÿ¨: $message");
      
      if (message['event'] == 'driver-location-update') {
        final driverData = message['data'];
        
        if (driverData != null) {
          final latitude = double.tryParse(driverData['latitude']?.toString() ?? '0') ?? 0.0;
          final longitude = double.tryParse(driverData['longitude']?.toString() ?? '0') ?? 0.0;
          
          print("üìç ŸÖŸàŸÇÿπ ÿßŸÑÿ≥ÿßÿ¶ŸÇ ÿßŸÑŸÖÿ≠ÿØÿ´: lat=$latitude, lng=$longitude");
          
          setState(() {
            driverLocation = LatLng(latitude, longitude);
          });
          
          // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿ™ÿ≠ÿØŸäÿ´ ŸÖŸàŸÇÿπ ÿßŸÑÿ≥ÿßÿ¶ŸÇ (ŸÅŸÇÿ∑ ŸÅŸä ÿßŸÑŸÖÿ±ÿ© ÿßŸÑÿ£ŸàŸÑŸâ)
          if (scaffoldKey.currentContext != null && 
              (driverLocation.latitude != 0.0 || driverLocation.longitude != 0.0)) {
            ScaffoldMessenger.of(scaffoldKey.currentContext!).showSnackBar(
              SnackBar(
                content: Text('Driver location updated!'),
                backgroundColor: Colors.green,
                duration: Duration(seconds: 1),
              ),
            );
          }
        }
      } else if (message['event'] == 'order-status-update') {
        final statusData = message['data'];
        print("üîÑ ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ®: $statusData");
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ®
        if (statusData != null) {
          final oldStatus = order.orderStatus.status;
          setState(() {
            order.orderStatus.status = statusData['status'] ?? order.orderStatus.status;
            order.orderStatus.id = statusData['status_id']?.toString() ?? order.orderStatus.id;
          });
          
          // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ∑ŸÑÿ®
          if (scaffoldKey.currentContext != null && 
              statusData['status'] != null && 
              statusData['status'] != oldStatus) {
            ScaffoldMessenger.of(scaffoldKey.currentContext!).showSnackBar(
              SnackBar(
                content: Text('Order status updated: ${statusData['status']}'),
                backgroundColor: Colors.blue,
                duration: Duration(seconds: 2),
              ),
            );
          }
        }
      }
      
    } catch (e) {
      print("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿ±ÿ≥ÿßŸÑÿ© WebSocket: $e");
    }
  }

  // ÿØÿßŸÑÿ© ŸÑÿ•ÿ∫ŸÑÿßŸÇ ÿßÿ™ÿµÿßŸÑ WebSocket
  void disconnectFromDriverTracking() {
    try {
      print("üîå ÿ•ÿ∫ŸÑÿßŸÇ ÿßÿ™ÿµÿßŸÑ WebSocket");
      _driverTrackingChannel?.sink.close();
      _isDriverTrackingConnected = false;
      setState(() {});
      
      // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿßÿ™ÿµÿßŸÑ
      if (scaffoldKey.currentContext != null) {
        ScaffoldMessenger.of(scaffoldKey.currentContext!).showSnackBar(
          SnackBar(
            content: Text('Live tracking disconnected.'),
            backgroundColor: Colors.grey,
            duration: Duration(seconds: 1),
          ),
        );
      }
    } catch (e) {
      print("‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿ∫ŸÑÿßŸÇ WebSocket: $e");
    }
  }

  // ÿØÿßŸÑÿ© ŸÑÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿ™ÿ±ÿßŸÉŸÜÿ¨ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±
  void reconnectToDriverTracking(String orderId) {
    print("üîÑ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿ™ÿ±ÿßŸÉŸÜÿ¨ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±");
    disconnectFromDriverTracking();
    Future.delayed(Duration(seconds: 2), () {
      connectToDriverTracking(orderId);
    });
    
    // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ
    if (scaffoldKey.currentContext != null) {
      ScaffoldMessenger.of(scaffoldKey.currentContext!).showSnackBar(
        SnackBar(
          content: Text('Reconnecting to live tracking...'),
          backgroundColor: Colors.blue,
          duration: Duration(seconds: 2),
        ),
      );
    }
  }

  // ÿØÿßŸÑÿ© ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ
  bool get isDriverTrackingConnected => _isDriverTrackingConnected;

  Future<void> setClientLocationFromDevice() async {
    print("mElkerm Tracking Controller ‚ñ∂ Getting current device location...");

    bool serviceEnabled;
    LocationPermission permission;

    // Check if location services are enabled
    serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      print("mElkerm Tracking Controller ‚ùå Location services are disabled.");
      return;
    }

    // Check for permissions
    permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        print("mElkerm Tracking Controller ‚ùå Location permission denied.");
        return;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      print(
        "mElkerm Tracking Controller ‚ùå Location permission permanently denied.",
      );
      return;
    }

    // Get the current position
    Position position = await Geolocator.getCurrentPosition(
      desiredAccuracy: LocationAccuracy.high,
    );

    print(
      "mElkerm Tracking Controller ‚úÖ Location obtained: ${position.latitude}, ${position.longitude}",
    );

    setState(() {
      clientLocation = LatLng(position.latitude, position.longitude);
    });
  }

  void listenForOrder({required String orderId, String? message}) async {
    print(
      "mElkerm Tracking Controller ‚ñ∂ Starting listenForOrder for ID: $orderId",
    );
    
    // ÿ®ÿØÿ° ÿßŸÑÿ™ÿ±ÿßŸÉŸÜÿ¨ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ± ŸÑŸÑÿ≥ÿßÿ¶ŸÇ
    connectToDriverTracking(orderId);
    
    final Stream<Order> stream = await getOrder(orderId);
    print(
      "mElkerm Tracking Controller ‚úÖ Stream obtained for order ID: $orderId",
    );

    stream.listen(
      (Order _order) {
        setState(() {
          print("mElkerm Tracking Controller ‚ñ∂ Received order data");
          print("mElkerm Tracking Controller ‚Üí order id: ${_order.id}");
          print(
            "mElkerm Tracking Controller ‚Üí order status id: ${_order.orderStatus.id}",
          );
          print(
            "mElkerm Tracking Controller ‚Üí order status: ${_order.orderStatus.status}",
          );
          print("mElkerm Tracking Controller ‚Üí order date: ${_order.dateTime}");
          print(
            "mElkerm Tracking Controller ‚Üí payment method: ${_order.payment.method}",
          );
          print("mElkerm Tracking Controller ‚Üí active: ${_order.active}");
          print("mElkerm Tracking Controller ‚Üí hint: ${_order.hint}");
          print(
            "mElkerm Tracking Controller ‚Üí lat: ${_order.deliveryAddress.longitude}",
          );
          print(
            "mElkerm Tracking Controller ‚Üí lang: ${_order.deliveryAddress.latitude}",
          );
          restaurantLocation = LatLng(
            double.tryParse(_order.deliveryAddress.latitude.toString()) ?? 0.0,
            35.4219985,
          );

          print(
            "mElkerm Tracking Controller ‚Üí restaurant location: $restaurantLocation",
          );
          // setClientLocationFromDevice();

          restaurantLocation = LatLng(31.532640, 35.098614);
          clientLocation = LatLng(31.536833, 35.050363);
          print(
            "mElkerm Tracking Controller ‚Üí restaurant location: $restaurantLocation",
          );

          order = _order;
        });
      },
      onError: (a) {
        print("mElkerm Tracking Controller ‚ùå Error in listenForOrder: $a");
        ScaffoldMessenger.of(scaffoldKey.currentContext!).showSnackBar(
          SnackBar(
            content: Text(S.of(state!.context).verify_your_internet_connection),
          ),
        );
      },
      onDone: () {
        print("mElkerm Tracking Controller ‚úÖ listenForOrder stream done");
        listenForOrderStatus();
        if (message != null) {
          ScaffoldMessenger.of(
            scaffoldKey.currentContext!,
          ).showSnackBar(SnackBar(content: Text(message)));
        }
      },
    );
  }

  TrackingOrderModel? trackingOrderDetails = null;

  Future<void> getOrderDetailsTracking({
    required String orderId,
    String? message,
  }) async {
    print(
      "mElkerm Tracking Controller ‚ñ∂ Start getOrderDetailsTracking for ID: $orderId",
    );
    setState(() {
      // Optional: loading state
    });

    try {
      final result = await getTrackingOrderModel(orderId: orderId);
      print("mElkerm Tracking Controller ‚úÖ Tracking data fetched successfully");

      setState(() {
        trackingOrderDetails = result;
      });

      if (message != null) {
        ScaffoldMessenger.of(
          scaffoldKey.currentContext!,
        ).showSnackBar(SnackBar(content: Text(message)));
      }

      listenForOrderStatus();
    } catch (error) {
      print(
        "mElkerm Tracking Controller ‚ùå Error fetching tracking data: $error",
      );
      
      // ÿ™ÿ≠ŸÑŸäŸÑ ŸÜŸàÿπ ÿßŸÑÿÆÿ∑ÿ£ ŸÑÿ™ŸÇÿØŸäŸÖ ÿ±ÿ≥ÿßŸÑÿ© ÿ£ŸÉÿ´ÿ± Ÿàÿ∂Ÿàÿ≠ÿßŸã
      String errorMessage = "Failed to load tracking information";
      
      if (error.toString().contains("User API token not available")) {
        errorMessage = "Please login again to view tracking information";
      } else if (error.toString().contains("Order not found")) {
        errorMessage = "Order not found. Please check the order ID.";
      } else if (error.toString().contains("Unauthorized")) {
        errorMessage = "Unauthorized. Please login again.";
      } else if (error.toString().contains("Empty response")) {
        errorMessage = "No tracking data available for this order.";
      } else if (error.toString().contains("Failed to load tracking data")) {
        errorMessage = "Tracking data is not available for this order.";
      }
      
      if (scaffoldKey.currentContext != null) {
        ScaffoldMessenger.of(scaffoldKey.currentContext!).showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 4),
          ),
        );
      }
    }
  }

  void listenForOrderStatus() async {
    print("mElkerm Tracking Controller ‚ñ∂ Start listening for order statuses");
    final Stream<OrderStatus> stream = await getOrderStatus();
    print("mElkerm Tracking Controller ‚úÖ OrderStatus stream obtained");

    stream.listen(
      (OrderStatus _orderStatus) {
        setState(() {
          print(
            "mElkerm Tracking Controller ‚Üí Received status: ${_orderStatus.status} (ID: ${_orderStatus.id})",
          );
          orderStatus.add(_orderStatus);
        });
      },
      onError: (a) {
        print("mElkerm Tracking Controller ‚ùå Error in order status stream: $a");
      },
      onDone: () {
        print("mElkerm Tracking Controller ‚úÖ Order status stream done");
      },
    );
  }

  // ÿØÿßŸÑÿ© ŸÑÿ•ÿ∫ŸÑÿßŸÇ ÿ¨ŸÖŸäÿπ ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™ ÿπŸÜÿØ ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿµŸÅÿ≠ÿ©
  void dispose() {
    print("üßπ ÿ™ŸÜÿ∏ŸäŸÅ ŸÖŸàÿßÿ±ÿØ ÿßŸÑÿ™ÿ±ÿßŸÉŸÜÿ¨");
    disconnectFromDriverTracking();
    super.dispose();
  }

  List<Step> getTrackingSteps(BuildContext context, int currentOrderStatus) {
    print("mElkerm Tracking Controller ‚ñ∂ Building tracking steps");
    List<Step> _orderStatusSteps = [];
    List<OrderStatus> statuses = [...this.orderStatus];

    for (OrderStatus status in statuses) {
      print(
        "mElkerm Tracking Controller ‚Üí Status name: ${status.status}, ID: ${status.id}",
      );
    }

    statuses.removeWhere((element) => element.id == "6" || element.id == "7");
    if (order.payment.method == "Pay on Pickup") {
      statuses.removeWhere((element) => element.id == "5" || element.id == "4");
    }

    statuses.forEach((OrderStatus _orderStatus) {
      _orderStatusSteps.add(
        Step(
          state: StepState.complete,
          title: Text(
            _orderStatus.status,
            style: Theme.of(context).textTheme.titleMedium,
          ),
          subtitle:
              order.orderStatus.id == _orderStatus.id
                  ? Text(
                    '${DateFormat('HH:mm | yyyy-MM-dd').format(order.dateTime)}',
                    style: Theme.of(context).textTheme.bodySmall,
                    overflow: TextOverflow.ellipsis,
                  )
                  : SizedBox(height: 0),
          content: SizedBox(
            width: double.infinity,
            child: Text('${Helper.skipHtml(order.hint)}'),
          ),
          isActive:
              (currentOrderStatus + 1) >= (int.tryParse(_orderStatus.id)!),
        ),
      );
    });

    print("mElkerm Tracking Controller ‚úÖ Finished building steps");
    return _orderStatusSteps;
  }

  Future<void> refreshOrder() async {
    print("mElkerm Tracking Controller ‚ñ∂ Refreshing order");
    order = new Order();
    listenForOrder(
      orderId: order.id,
      message: S.of(state!.context).tracking_refreshed_successfuly,
    );
    getOrderDetailsTracking(
      orderId: order.id,
      message: S.of(state!.context).tracking_refreshed_successfuly,
    );
  }

  void doCancelOrder() {
    print("mElkerm Tracking Controller ‚ñ∂ Starting cancel order");
    cancelOrder(this.order)
        .then((value) {
          setState(() {
            print("mElkerm Tracking Controller ‚úÖ Order marked as inactive");
            this.order.active = false;
          });
        })
        .catchError((e) {
          print("mElkerm Tracking Controller ‚ùå Error cancelling order: $e");
          ScaffoldMessenger.of(
            scaffoldKey.currentContext!,
          ).showSnackBar(SnackBar(content: Text(e)));
        })
        .whenComplete(() {
          print("mElkerm Tracking Controller ‚úÖ Cancel order flow complete");
          orderStatus = [];
          listenForOrderStatus();
          ScaffoldMessenger.of(scaffoldKey.currentContext!).showSnackBar(
            SnackBar(
              content: Text(
                S
                    .of(state!.context)
                    .orderThisorderidHasBeenCanceled(this.order.id),
              ),
            ),
          );
        });
  }

  bool canCancelOrder(Order order) {
    print("mElkerm Tracking Controller ‚ñ∂ Checking if order can be cancelled");
    return order.active == true && order.orderStatus.id == 1;
  }
}
